# Research Methods

# I spent 1 hour on this challenge.

i_want_pets = ["I", "want", 3, "pets", "but", "only", "have", 2]
my_family_pets_ages = {"Evi" => 6, "Ditto" => 3, "Hoobie" => 3, "George" => 12, "Bogart" => 4, "Poly" => 4, "Annabelle" => 0}

# Person 1's solution: Brian Bensch
def my_array_finding_method(source, thing_to_find)
  source.select { |word| word.to_s.include? thing_to_find}
end

def my_hash_finding_method(source, thing_to_find)
  new_hash = source.keep_if {|a,b| b == thing_to_find}
  new_hash.keys
end

# Identify and describe the Ruby method(s) you implemented.
=begin
Identify and describe the Ruby method(s) you implemented.
1) For this first one I used the select method which basically iterates through each element in the
array. I then had to convert each element to a string, since I was going to be then calling the
include? method to see if each individual element contained the letter provided in the argument
2) For the next one I ended up using two methods but couldn't figure out how to combine them into
one refactored line. First, I called .keep_if on the hash, which iterates through each key-value
pair and keeps it based on whether the value ("b" in my block) is equal to the thing we're looking
for, in the case the age of the dogs. This first method returns back another hash though, so I
created a new variable called new_hash, which I called the .keys method on, to return just the dog
names that match the age we're looking for.
See my psuedocode sections for more details on how I worked through them. In general I followed the
advice of the release 1 reading of skimming through all of the methods listed on the left nav bar
for the given class you're looking, and making a note of which ones seem reasonable. Then just go
through them one at a time and start trying things out.
=end

# Person 2: Natalie Polen
def my_array_modification_method!(source, thing_to_modify)
  source.map! {|elem|
    if elem.is_a?(Integer)
      elem += thing_to_modify
    else
      elem
    end
   }
end

def my_hash_modification_method!(source, thing_to_modify)
  source.each do |pet,age|
    source[pet] = age + thing_to_modify
  end
  return source
end

# Identify and describe the Ruby method(s) you implemented.
# 1. map!: works similarly to "each," which I think people
#          are more familiar with. The destructive "map!"
#          replaces the element permanently.
# 2. is_a?: returns a boolean and takes a class (i.e. Integer
#           as above) as an argument.
# 3. each: works through each element of a hash or array and
#          does the same thing to that element.


# Person 3: Timothy Meixell
def my_array_sorting_method(source)
  source.sort_by{ |x| x.to_s }
end

def my_hash_sorting_method(source)
  source.to_a.sort_by{ |x| x[1] }
end

# Identify and describe the Ruby method(s) you implemented.
=begin 
Explanation:
The sort method returns a new array (so I don't have to make a copy), after using the results from the combined comparison operator (<=>). The problem is, you can't compare objects of different types. So I used the Enumerator method sort_by, which uses the keys generated by the block to sort the array. The block takes each item "x" and makes it a string (x.to_s) for comparison, if it isn't already.
The methods to_a and sort_by are non destructive, so I never need to make a copy like in my pseudocode. The method to_a turns the hash into an array. The problem this time is, you can't just compare two arrays. So I use a block to map each array "x" to x[1] for comparison, where the age integer is stored.
In both methods, the array generated is the last value accessed, and so they are implicitly returned. My "trick" for the docs is that I searched for the word "sort" on the ruby doc page and read what I could. If anyone wants to be walked through this, hit me on Slack.
=end


# Person 4: Ryan Ho
def my_array_deletion_method!(source, thing_to_delete)
  source.reject! {|user_string| user_string.to_s.index(thing_to_delete) != nil}
  return source
end

def my_hash_deletion_method!(source, thing_to_delete)
  source.reject! {|key| key == thing_to_delete }
  return source
end

# Identify and describe the Ruby method(s) you implemented.
# For both array and hash deletion methods, I used the .reject! method
# For the array method, I used the .to_s and .index methods to check if each string in the array contained the user entered letter.


# Person 5
def my_array_splitting_method(source)
  source # This line is here to make sure all tests initially fail. Delete it when you begin coding.
end

def my_hash_splitting_method(source, age)
  source # This line is here to make sure all tests initially fail. Delete it when you begin coding.
end

# Identify and describe the Ruby method(s) you implemented.
#
#
#